pragma solidity ^0.5.16;

import "./UniswapFlashSwapper.sol";

contract EmnExploitStudy is UniswapFlashSwapper {

    function flashSwap() external {

        address tokenBorrow = address(0xc7AD46e0b8a400Bb3C915120d284AafbA8fc4735); // flash borrowing rinkeby DAI
        uint256 amount = 1000000000000000000000000; // the actual exploit involved flashing $15M worth of DAI but we're using 1 ETH here for demo purposes
        address tokenPay = address(0xc7AD46e0b8a400Bb3C915120d284AafbA8fc4735); // repaying flash swap with rinkeby DAI
        bytes memory userData = "";

        // execute flash swap
        startSwap(tokenBorrow, amount, tokenPay, userData);

        // now that the flash loan has been repaid, clean up loose ends
        executePsyOps();
    }

    // Mid-flash loan logic i.e. what you do with the temporarily acquired flash liquidity
    function execute(address _tokenBorrow, uint _amount, address _tokenPay, uint _amountToRepay, bytes memory _userData) internal {
        // approve DAI on EMN contract
        // Mint EMN with all available flash liquidity
        // approve eAAVE on EMN contract
        // burn half of EMN for eAAVE
        // burn other half of EMN back into DAI
        // mint EMN from eAAVE
        // burn remainder EMN back into DAI
    }

    // @notice Simple getter for convenience while testing
    function getBalanceOf(address _input) external view returns (uint) {
        if (_input == address(0)) {
            return address(this).balance;
        }
        return IERC20(_input).balanceOf(address(this));
    }

    // but IDK tho, might be psyops
    function executePsyOps() internal {
        // transfer $8M to the 'Yearn: Deployer' contract to divert attention to Andre
    }
}
